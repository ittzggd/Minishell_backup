파이프에서 문제가 되는 부분이 무조건 파이프 이후에 다시 파이프 실행했을 때가 아닌
1. execv 함수 들로만 구성된 명령어일 경우 파이프 몇 번을 실행해도 문제 없음
2. execv함수가 아닌 빌트인 함수일 경우 파이프이용하는 첫 명령어여도 제대로 실행 x
	-> 제대로 실행이 안 된다는 것은 파이프 뒤 명령어에 대한 output 2번 발생

그래서 우리가 구현한 빌트인 함수들이랑 execㅍ사용한 함수들이랑 차이가 뭘까 생각해봤는데
파이프, fork 없이 그냥 nanoshell 이었을 때 -> 인 줄 알았는데 알고보니까 있던거였음 그래서 다시 포크 하기 전 시절로 돌아가서 해봤는데 암튼
파이프 없이 단일로 실행한 경우
1. 빌트인 함수들은 함수실행 후에도 nanoshell 계속 유지됨, 즉 실행후 다시 나노쉘로 돌아옴
	-> while (1) 동안 계속 읽어냄서 실행하니까
2. ls, sleep 등과 같이 빌트인 함수가 아닌 경우에 nanoshell 유지가 아닌 명령어 실행후 nanoshell까지 종료해버림


execv 함수는 다른 프로그램을 실행시키고 자기 자신을 종료 그래서 그런것이었음
-> minishell에서 minishell 실행시킬 때에도 exit 한 번에 아예 걍 다 꺼져버린 이유가
 minishell 실행 상태에서 두번째로 실행시키는 minishell을 실행시켜줌과동시에
 기존의 minishell은 종료되어버리기 때문

 근데 왜 pipe 있으면 남아있지...?  => 왜냠 pipe 있으면 함수들이 자식 프로세스에서 실행되기 때문에
 즉 builtin 함수들을 파이프와 함께 사용했을 때 꼬이는 이유는 자식 프로세스들이 완전히 종료되지 않아서? 파이프가 제대로 닫히지 않아서?
 라고 추측을 하는 중...
 자식프로세스를 죽이지 않았기 때문에 계속 자식 프로세스도 readline으로 불러올꺼란말이지
 그래서 꼬이는 것 같다는 추측...
 우리가 SIGKILL시그널로 자식 프로세스를 안 죽여서...? 아마...? 

 해서 우리는 시그널처리를 같이 생각하는게 좋을 것 같다..?